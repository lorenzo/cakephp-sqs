<?php

App::uses('QueueWorkerTask', 'SQS.Console/Command/Task');
App::uses('SimpleQueue', 'SQS.Model');

/**
 * Tests SimpleQueue class
 *
 **/
class QueueWorkerTaskTest extends CakeTestCase {

/**
 * Sets up a mocked logger stream
 *
 * @return void
 **/
	public function setUp() {
		parent::setUp();
		$this->task = new QueueWorkerTask;
	}

/**
 * Restores everything back to normal
 *
 * @return void
 **/
	public function tearDown() {
		parent::tearDown();
		CakeLog::enable('stderr');
		CakeLog::drop('queuetest');
		Configure::write('SQS', array());
		unset($this->logger);
	}

/**
 * Tests getWorker function
 *
 * @return void
 */
	public function testGetWorker() {
		$this->assertInstanceOf('SimpleQueue', $this->task->getWorker());
	}

/**
 * Tests getEventManager function
 *
 * @return void
 */
	public function testGetEventManager() {
		$this->assertInstanceOf('CakeEventManager', $this->task->getEventManager());
	}

/**
 * Tests the infinite-looping worker function
 *
 * @expectedException Exception
 * @expectedExceptionMessage break the cycle
 * @return void
 */
	public function testWork() {
		Configure::write('SQS.queues.job1', 'http://ok.dk/');
		Configure::write('SQS.queues.job2', 'http://ok.dk/');

		$task = $this->getMock('QueueWorkerTask', array('getEventManager', 'log', 'getWorker'));

		// Making a mocked SimpleQueue and making getWorker always return it
		$queue = $this->getMock('SimpleQueue', array('receiveMessage', 'deleteMessage'));
		$task
			->expects($this->any())
			->method('getWorker')
			->will($this->returnValue($queue));

		//Making a mocked CakeEventManager and making getEventManager always return it
		$manager = $this->getMock('CakeEventManager');
		$task
			->expects($this->any())
			->method('getEventManager')
			->will($this->returnValue($manager));

		$manager
			->expects($this->at(0))
			->method('dispatch')
			->with(new CakeEvent('Queue.beforeWork', $task));
		$manager
			->expects($this->at(1))
			->method('dispatch')
			->with(new CakeEvent('Queue.afterWork', $task));

		// Faking the first message that will be received from the job1 queue
		$message = array(array('ReceiptHandle' => 'myId', 'Body' => json_encode('foo')));
		$model = $this->getMock('\Guzzle\Service\Resource\Model');
		$model
			->expects($this->exactly(2))
			->method('get')
			->with('Messages')
			->will($this->returnValue($message));
		$queue
			->expects($this->at(0))
			->method('receiveMessage')
			->with('job1')
			->will($this->returnValue($model));

		// Telling the task to handle the queue job1 with a method in this test class
		$task->addFunction('job1', $this, 'handleJob');

		// the second queue to manage will be job2
		$manager
			->expects($this->at(2))
			->method('dispatch')
			->with(new CakeEvent('Queue.beforeWork', $task));
		$manager
			->expects($this->at(3))
			->method('dispatch')
			->with(new CakeEvent('Queue.afterWork', $task));

		// Faking the first message that will be received from the job2 queue
		$message = array(array('ReceiptHandle' => 'mySecondID', 'Body' => json_encode('foo2')));
		$model = $this->getMock('\Guzzle\Service\Resource\Model');
		$model
			->expects($this->exactly(2))
			->method('get')
			->with('Messages')
			->will($this->returnValue($message));
		$queue
			->expects($this->at(2))
			->method('receiveMessage')
			->with('job2')
			->will($this->returnValue($model));

		// Telling the task to handle the queue job2 with a method in this test class
		$task->addFunction('job2', $this, 'handleJob2');

		// In the next cycle of the infinte loop it is the turn to manage job1 again
		$manager
			->expects($this->at(4))
			->method('dispatch')
			->with(new CakeEvent('Queue.beforeWork', $task));

		// Faking the first message that will be received from the job1 queue
		// This time and exception will be thrown to break the infinite loop
		$message = array(array('ReceiptHandle' => 'myThirdId', 'Body' => json_encode('foo3')));
		$model = $this->getMock('\Guzzle\Service\Resource\Model');
		$model
			->expects($this->exactly(2))
			->method('get')
			->with('Messages')
			->will($this->returnValue($message));
		$queue
			->expects($this->at(3))
			->method('receiveMessage')
			->with('job1')
			->will($this->returnValue($model));

		// Only the first handleJob function returns true, so only message will be deleted
		$queue->expects($this->once())->method('deleteMessage')->with('job1', 'myId');

		$task->work();
	}

/**
 * Function that will handle jobs generated by the first queue
 * when data equals foo3 it will throw an exception
 *
 * @return boolean
 */
	public function handleJob($data) {
		if ($data === 'foo3') {
			throw new Exception('break the cycle');
		}

		$this->assertEquals('foo', $data);
		return true;
	}

/**
 * Function that will handle jobs generated by the second queue
 *
 * @return boolean
 */
	public function handleJob2($data) {
		$this->assertEquals('foo2', $data);
		return false;
	}

}
